#! /bin/bash
#
# wrapper around all evo systemd ExecStart= command so that :
# 1) we get better control of how environment variables are affected 
#    re: systemd cannot perform environment variable expension which makes it possible to cumulate
#        changes to variables like LD_LIBRARY_PATH, PATH, LD_PRELOAD etc...
#        Note: TODO
#
# 2) work around PR 1075866
#    We are unable to eliminate this sh shell-init getcwd() warning. Seems to be an consequence of
#    using unionfs and pivoting to it during init phase. Using a wrapper to have it chdir() to /usr/sbin
#    instead of using the systemd service config parameter WorkingDirectory=/usr/sbin eliminates
#    these messages.

#
# source a common.env and any *.env files in common_env.d
# source a ${app}.env and and *.env files in ${app}_env.d
#
exec 2>>/var/log/evostart.log
export PS4='$(printf "%(%H:%M.%S)T") [$$] ${BASH_SOURCE}:${LINENO} - '
set -x
# Makefile.inc should install into common or app specific files under this directory.
envRoot=/usr/evo/env
systemdUnitEnvRoot=/usr/evo/env/systemd-unit/
cmnDir=common_env.d
asan=060_asan


# Find the sysgemd unit name of a process (pid).
function getSystemdUnitName () {
    SYSTEMCTL=/bin/systemctl
    AWK=/usr/bin/awk
    pid=$1
    local status=`$SYSTEMCTL status ${pid} 2>/dev/null | head -1`

    # * app.service app.service description
    if ! [[ -z "${status}" ]]; then
        unit_name=`echo "$status" | $AWK '{print $2}'`
        echo ${unit_name%.*}
    fi
}

# Source environment files from a given directory.
function sourceItFromDir ()
{
    use_dir=$1
    id=$2

    env_file=${use_dir}/${id}.env
    env_dir=${use_dir}/${id}_env.d

    [ -f ${env_file} ] && . ${env_file}
    if [[ -d ${env_dir} ]]; then
        for envFile in ${env_dir}/*
        do
            [ -f $envFile ] && . $envFile
        done
    fi
}

# Evostart would look at following directories to find env files
#   - /usr/evo/env/<app>_env.d
#   - /usr/evo/env/system-unit/<unit-name>_env.d
function sourceIt ()
{
    appname=$1
    systemd_unit_name=$2

    if ! [[ -z "${appname}" ]]; then
        sourceItFromDir ${envRoot} ${appname}
    fi

    if ! [[ -z "${systemd_unit_name}" ]]; then
        sourceItFromDir ${systemdUnitEnvRoot} ${systemd_unit_name}
    fi
}

function attachNetwork () {
    local network=$1
    local switchVrfTool="/usr/sbin/switchvrf"
    local mypid=$$
    local vrf=""
    local mgmt_junos=0

    case $network in
	internal)
	    vrf="vrf0"
	    ;;
	iri)
	    vrf="iri"
	    enabled=`cat /usr/conf/system/enable_iri 2>/dev/null || echo 0`
	    if [[ ${enabled} -ne 1 ]]
	    then
		echo "$0: error: VRF iri is not enabled" 1>&2
		exit 1
	    fi
	    ;;
	management | external)
            vrf="vrf0"
            mgmt_junos=`cat /usr/conf/system/set_mgmt_instance 2>/dev/null || echo 0`
            if [[ ${mgmt_junos} -eq 1 ]]
	    then
		vrf="mgmt_junos"
            fi
	    ;;
	*)
	    # No valid vrf, corresponding to the network arg
	    echo "$0: error: Unknown VRF $network" 1>&2
	    exit 1
	    ;;
    esac

    # Switch the vrf
    ${switchVrfTool} ${mypid} ${vrf}
    if [ $? -ne 0 ]; then
        echo "$0: error: Network Attach ($vrf) failed" 1>&2
        exit 1
    fi
}

argWorkingDir="/usr/sbin"
argNetwork=""
argSkipAsan=""
argSystemdUnitPrefix=""

# Parsing Evostart Arguments
# Usage :
#   -n : network
#   -d : working directory
#   -s : skip asan
#   -p : systemd unit prefix

for arg in {1..4}; do
    case $1 in
        "-d" )
            argWorkingDir="$2"
            ;;
        "-n" )
            argNetwork="$2"
            ;;
        "-s" )
            argSkipAsan="$2"
            ;;
        "-p" )
            argSystemdUnitPrefix="$2"
            ;;
        * )
            break
            ;;
    esac

    # Assuming arguments will be name value pair
    shift 2
done

# Change to working directory
cd ${argWorkingDir}

# Attach to network
if [ "$argNetwork" ]
then
    nodetype=`nodeinfo --getNodeType`
    if [ "$nodetype" == "RE" ]
    then
	attachNetwork ${argNetwork}
    else
	echo "$0: warning: Use of -n $argNetwork on card type $nodetype.  Ignoring." 1>&2
    fi
fi

# Initialize both before any of the initialization scripts are run, so
# the initialization scripts have a chance to modify them.
# ld_preload is the current list of libraries that must be preloaded#
[ -f /usr/evo/trackeron ] || ld_preload=
ld_path=
envs=

appName=$(basename $1)
sourceIt common

if [[ -z ${argSystemdUnitPrefix} ]]; then
    systemdUnitName=$(getSystemdUnitName $$)
    sourceIt ${appName} ${systemdUnitName}
else
    sourceIt ${appName} ${argSystemdUnitPrefix}
fi

if [[ -f ${envRoot}/${cmnDir}/${asan} && -z ${argSkipAsan} ]]; then
    envs="ASAN_OPTIONS=halt_on_error=0:disable_core=1:detect_leaks=0 ${envs} LD_PRELOAD=${ld_preload}"
    if [[ "${envs}" =~ "LD_PRELOAD" ]]; then
        envs=${envs/LD_PRELOAD=/LD_PRELOAD=libasan.so.5:}
    else
        envs="LD_PRELOAD=libasan.so.5 ${envs}"
    fi
else
    envs="LD_PRELOAD=${ld_preload} ${envs}"
fi

if [ -n "${ld_path}" ]; then
    ld_path="LD_LIBRARY_PATH=${ld_path}"
fi

if [[ "${envs}" =~ "ASAN_OPTIONS" ]]; then
    # Try to ensure that no core files are generated if ASAN_OPTIONS are set
    # in theory, disable_core=1 should be set to accomplish this, but
    # use the belt and suspenders approach to ensure this is the case.
    ulimit -c 0
    # ignore limits for asan
    echo Y > /sys/module/kernel/parameters/ignore_rlimit_data
fi

exec_line="exec env ${ld_path} ${envs} $*"

# Uncomment the following line to determine what command is executed.
#echo ${exec_line}

# reset historic file accesses before exec
cat < /utrigger > /dev/null

eval ${exec_line}
